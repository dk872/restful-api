# Гайд на створення RESTful API мовою Python з використанням SQLAlchemy та FastAPI
**Автори:**

*студент 2-го курсу, групи ІМ-32*<span padding-right:5em></span> **Дмитро КУЛИК** [Telegram](https://t.me/dimakulyk2005)

*студент 2-го курсу, групи ІМ-32*<span padding-right:5em></span> **Лев БЕРЕЗА** [Telegram](https://t.me/levbereza)

## Короткий зміст

- [Вступ](#вступ)
- [Основи RESTful API](#основи-restful-api)
- [Огляд архітектури FastAPI та SQLAlchemy](#огляд-архітектури-fastapi-та-sqlalchemy)
- [Налаштування середовища](#налаштування-середовища)
- [Приклад бази даних](#приклад-бази-даних)
- [Підключення до бази даних](#підключення-до-бази-даних)
- [Створення Pydantic-схем та моделей SQLAlchemy](#створення-pydantic-схем-та-моделей-sqlalchemy)
- [Реалізація основних маршрутів API](#реалізація-основних-маршрутів-api)
- [Запуск сервера FastAPI і тестування](#запуск-сервера-fastapi-і-тестування)
- [Документація FastAPI](#документація-fastapi)
- [Висновки](#висновки)
- [Посилання](#посилання)

## Вступ
Сьогодні RESTful API є важливою складовою сучасних веб-додатків і сервісів, оскільки вони дозволяють організувати взаємодію між клієнтами та сервером за допомогою HTTP-запитів. RESTful API використовують для створення, отримання, оновлення та видалення даних, що забезпечує високий рівень інтеграції між різними програмами та сервісами. Завдяки чітким принципам REST та стандартизованим HTTP-методам (GET, POST, PUT, DELETE) API стають зрозумілими й легкими у використанні.

У цьому гайді ми з'ясуємо, що таке RESTful API, які бібліотеки можна використовувати для його реалізації, а також на конкретному прикладі покажемо, як можна створити RESTful API для конкретної бази даних.

## Основи RESTful API

**REST** — абревіатура від REpresentational State Transfer (передача репрезентативного стану).

**RESTful API** — це архітектура інтерфейсу прикладних програм (API), що використовує HTTP-запити для доступу до ресурсів та їхнього використання. Такими HTTP-запитами є **GET**, **PUT**, **POST** і **DELETE**. Вони дають змогу, відповідно, читати, змінювати, створювати й видаляти ресурси.

Для кращого розуміння того, як працює REST API, уявімо, що у нас є веб-додаток. Цей додаток має дві основні частини: *frontend* (клієнтська частина) і *backend* (серверна частина).

REST API слугує мостом між цими двома частинами. Він дає змогу frontend надсилати запити до backend і отримувати дані звідти. Як це відбувається?

- Запити від клієнта до сервера: коли користувач додає товар до кошика на вебсторінці (frontend), JavaScript на сторінці створює HTTP-запит і відправляє його на сервер (backend). Запит може містити інформацію про товар, його кількість та інші деталі.
- Обробка запитів на сервері: сервер, отримавши запит, використовує REST API для інтерпретації його вмісту та виконання відповідної операції. Наприклад, він може перевірити доступність товару, зменшити кількість товару на складі та створити замовлення.
- Відповідь від сервера до клієнта: після опрацювання запиту сервер створює HTTP-відповідь і надсилає її назад на клієнтську сторону. Відповідь може містити інформацію про статус операції, оновлений стан даних або інші відомості.
- Оновлення інтерфейсу на клієнті: на клієнтському боці JavaScript обробляє HTTP-відповідь і, за необхідності, оновлює користувацький інтерфейс. Наприклад, він може оновити кошик користувача, показати повідомлення про успішну покупку тощо.

### Основні принципи REST API

REST API будується на кількох ключових принципах, які роблять його ефективним і гнучким інструментом для обміну даними.

1. **Stateless**: 
REST API працює в режимі “без стану” (stateless), що означає, що кожен HTTP-запит, надісланий на сервер, містить усі необхідні дані для його обробки. Сервер не зберігає інформацію про попередні запити від клієнта. Це робить систему більш надійною та масштабованою.
2. **Client-Server:** 
REST API суворо розділяє клієнтську та серверну частини програми. Це означає, що вони можуть розвиватися незалежно одна від одної. Клієнт може бути веб-браузером, мобільним додатком або будь-яким іншим клієнтським додатком, а сервер може бути написаний будь-якою мовою програмування.
3. **Uniform Interface**: 
REST API спирається на чотири основні інтерфейси: ресурси, HTTP-методи (GET, POST, PUT, DELETE), представлення ресурсів (як дані подано клієнту) і посилання між ресурсами. Це створює однаковість у способі взаємодії клієнта і сервера.
4. **Cacheable**: 
REST API підтримує кешування, що означає, що клієнт може тимчасово зберігати дані, щоб зменшити навантаження на сервер і поліпшити продуктивність.
5. **Layered System**: 
Сервери REST API можна організувати в шари, що робить їх більш гнучкими і масштабованими. Кожен шар виконує певні функції, і їх можна додавати або видаляти без зміни клієнтського коду.

### Основні HTTP-методи

Отже, в REST API використовуються 4 основні HTTP-методи: GET, POST, PUT, DELETE

- **GET**: цей метод використовується для отримання даних із сервера. Коли клієнт надсилає GET-запит, сервер повертає запитані дані без їхньої зміни. Наприклад, GET-запит може використовуватися для отримання інформації про товар на веб-сторінці магазину.
- **POST**:  цей запит використовується для надсилання даних на сервер. Він дозволяє клієнту створювати нові ресурси на сервері або надсилати дані для обробки. Наприклад, POST-запит може використовуватися для створення нового запису в базі даних.
- **PUT**: призначений для оновлення наявних даних на сервері. Клієнт надсилає дані, які мають замінити наявні дані на сервері. Наприклад, PUT-запит може використовуватися для оновлення інформації про користувача.
- **DELETE**: використовується для видалення ресурсів на сервері. Цей метод дозволяє клієнту видаляти дані або ресурси, які більше не потрібні. Наприклад, DELETE-запит може використовуватися для видалення облікового запису користувача.

## Огляд архітектури FastAPI та SQLAlchemy

### FastAPI

**FastAPI** —  це веб-фреймворк для створення API мовою Python.

FastAPI активно використовує декоратори, анотації типів та інтроспекцію коду, що дозволяє зменшити кількість шаблонного коду у веб-додатку. FastAPI автоматично генерує та відображає документацію відповідно до специфікації OpenAPI.

В основі FastAPI лежать дві бібліотеки - *Starlette* (ASGI-фреймворк) та *Pydantic* (для опису схем даних); FastAPI склеює їх та реалізує деякі додаткові можливості — реєстрацію уявлень через впровадження залежностей, роботу з аутентифікацією та авторизацією, автоматичну генерацію документації та інше. Можливе використання як асинхронних, так і синхронних уявлень.

### SQLALchemy

**SQLAlchemy** — інструментарій SQL та об'єктно-реляційне відображення для мови програмування Python, випущене під ліцензією MIT.

Він реалізує технологію програмування ORM (Object-Relational Mapping), яка пов'язує бази даних із концепціями об'єктно-орієнтованих мов програмування. SQLAlchemy дозволяє описувати структури баз даних та способи взаємодії з ними прямо на мові Python.

### Переваги FastAPI та SQLAlchemy
#### FastAPI:

1. **Швидкодія**: використовує асинхронні можливості Python та побудована на ASGI (Asynchronous Server Gateway Interface), що забезпечує високу продуктивність.
2. **Простота** використання: інтуїтивно зрозумілий синтаксис та автоматична генерація документації за допомогою Swagger UI та ReDoc полегшує розробку та тестування.
3. **Валідація даних**: інтеграція з Pydantic для забезпечення валідації та серіалізації даних, що дозволяє уникати помилок під час передачі даних.
4. **Широка підтримка**: підтримує як синхронні, так і асинхронні функції, а також має широкі можливості інтеграції з іншими бібліотеками та системами.
5. **Модульність**: завдяки використанню роутерів та залежностей, забезпечує структуровану розробку, що полегшує масштабування та підтримку проєкту.

#### SQLAlchemy:

1. **Гнучкість**: дозволяє працювати як з об’єктно-реляційним відображенням (ORM), так і з чистим SQL, що дає змогу використовувати складні запити та адаптуватися під різні потреби.
2. **Модульність**: можливість використання різних модулів для управління транзакціями, підключення до бази даних та моделювання схем.
3. **Сумісність**: підтримує інтеграцію з багатьма реляційними базами даних (PostgreSQL, MySQL, SQLite тощо) через різні драйвери, що робить її універсальним рішенням для різних проєктів.

### Основні компоненти FastAPI

- `app`:
    - Основний об’єкт FastAPI, який визначає структуру додатка. Створюється як `app = FastAPI()`, використовується для реєстрації маршрутів та обробки запитів.
    - Виконує функції налаштування середовища додатка та обробки middleware.
- `Router`:
    - Компонент для розділення маршрутів на окремі модулі, що полегшує підтримку великого коду. `APIRouter()` використовується для створення груп маршрутів, що можуть бути включені до основного додатку через `app.include_router(router)`.
    - Забезпечує легкість тестування та модульність коду, дозволяючи розробникам краще організовувати логіку додатку.
- `Depends`:
    - Інструмент для впровадження залежностей. Дозволяє передавати загальні функції чи об'єкти (наприклад, підключення до бази даних, автентифікацію) в обробники запитів.
    - Залежності можуть бути синхронними або асинхронними, що дозволяє налаштовувати складні ланцюги залежностей.

### Основні компоненти SQLAlchemy

- `Engine`: 
    - Серце SQLAlchemy, що відповідає за підключення до бази даних. Створюється за допомогою `create_engine()` і приймає параметри підключення (наприклад, рядок підключення до бази).
    - Забезпечує взаємодію з базою даних через виконання SQL-запитів та управління транзакціями.
- `Session`:
    - У загальному розумінні, Session встановлює всі розмови з базою даних і представляє «зону зберігання» для всіх об’єктів, які ви завантажили або пов’язали з нею протягом її життя. Він надає інтерфейс, де виконуються SELECT та інші запити, які повертають і змінюють відображені ORM об’єкти. Самі об’єкти ORM зберігаються всередині Session, всередині структури, що називається ідентифікаційною картою – структура даних, яка підтримує унікальні копії кожного об’єкта, де «унікальний» означає «лише один об’єкт із певним первинним ключем».
- `Base`:
    - Базовий клас для визначення ORM моделей. Створюється як `Base = declarative_base()` і використовується для створення моделей таблиць за допомогою класів Python.
    - Служить основою для генерації схем таблиць у базі даних на основі визначених моделей.

### Взаємодія FastAPI та SQLAlchemy

- Зв’язок між FastAPI та SQLAlchemy забезпечується через залежності (Depends). Завдяки цьому FastAPI може автоматично передавати екземпляр сесії SQLAlchemy у маршрути для обробки запитів.
- Ініціалізація бази даних: після створення об’єкта Engine, база даних ініціалізується шляхом виклику `Base.metadata.create_all(bind=engine)`.
- Використання сесій: FastAPI дозволяє впроваджувати сесію бази даних у функції маршрутів через залежність `get_db()`, яка створює екземпляр сесії та автоматично закриває його після завершення запиту.

```python
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
from .database import SessionLocal, engine, Base

# Ініціалізація FastAPI
app = FastAPI()

# Створення бази даних
Base.metadata.create_all(bind=engine)

# Залежність для сесії
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.get("/items/")
def read_items(db: Session = Depends(get_db)):
    return db.query(Item).all()
```

## Налаштування середовища

Отже, можемо починати роботу. Для цього нам необхідно створити проєкт та 
та налаштувати середовище. Для цього будемо використовувати IDE PyCharm.
Його можна завантажити з [офіційного сайту](https://www.jetbrains.com/pycharm/download/?section=windows).
Далі маємо створити проєкт. Оскільки ми будемо працювати з FastAPI, то одразу
можемо обрати відповідну опцію:

![Create project](./images/environment/create-project.png)

Можна побачити що автоматисчно був створений файл `main.py`.
Для роботи створимо ще кілька файлів, а саме:
- config.py 
- routes.py 
- schemas.py
- models.py
- database.py

Для цього треба правою кнопкою мишки клікнути на головну папку вашого проєкту,
та обрати відповідні опції: 

![Create files](./images/environment/create-files.png)

Це ще не все. Для зручної роботи ми маємо встановити додаткові залежності, а саме:

- sqlalchemy
- mysql-connector-python
- pymysql

Для встановлення цих бібліотек ми маємо відкрити налаштування, перейти у вкладку
Project: "Ім'я проєкту", та обрати пункт Python Interpreter. 

![Dependencies](./images/environment/dependencies.png)

Ви побачите список вже влаштованих залежностей. Щоб додати нові треба натиснути
`+` вгорі спику. Там ви сможете знайти необхідні бібліотеки та встановити їх.

![Create files](./images/environment/install-dependencies.png)

Зробивши це ви побачити нові залежності у списку. Тепер можна починати роботу!

## Приклад бази даних
Припустимо, що в нас є база даних для інтернет-магазину або будь-якої іншої торгової платформи, яка займається продажем товарів. 
![](./images/database/1.png)

Таблиця Product зберігає інформацію про товари, які є в наявності. Вона дозволяє зберігати широкий асортимент товарів із вказанням їх характеристик, категорії, ціни та кількості на складі.

*Columns*
![](./images/database/2.png)
*Inserts*
![](./images/database/3.png)

Таблиця Orders зберігає інформацію про замовлення, зроблені клієнтами. Ця таблиця дозволяє відстежувати, які товари були замовлені, у якій кількості, та ким саме.

*Columns*
![](./images/database/4.png)
*Inserts*
![](./images/database/5.png)
*Foreign keys*
![](./images/database/6.png)

Таблиці Product та Orders пов'язані через зовнішній ключ **Product_id**, що дозволяє відстежувати, який саме товар був замовлений. Це є прикладом зв'язку **"один до багатьох"**: один товар може бути замовлений у багатьох замовленнях.

![](./images/database/7.png)

Нижче ми детально опишемо, як реалізувати RESTful Service для Order, проте в директорії ```/software``` ви можете знайти програмні коди з реалізацією як для Order, так і для Product. Let`s do it!)

## Підключення до бази даних
### database.py
Переходимо до конкретної реалізації. Почнемо з файлу **database.py**. Він буде містити конфігурацію підключення до бази даних у проєкті з використанням SQLAlchemy у поєднанні з FastAPI. Цей файл є ключовим для налаштування зв'язку між додатком та базою даних, а також створення сесій для взаємодії з базою даних.

![](./images/software/1.png)

**Імпорти:** *create_engine* - функція з SQLAlchemy, яка створює підключення до бази даних (це основа для виконання SQL-запитів); *declarative_base* використовується для створення базового класу моделей (таблиць) (це дозволяє визначати таблиці за допомогою Python-класів); *sessionmaker* - функція для створення фабрики сесій, сесія дозволяє виконувати операції (запити) з базою даних; *config* - файл, де зберігається змінна DB_PASSWORD з паролем root.

```python
SQLALCHEMY_DATABASE_URL = f"mysql+pymysql://root:{DB_PASSWORD}@127.0.0.1:3306/mydb"
```
Використовуємо драйвер **PyMySQL** для роботи з MySQL через SQLAlchemy. *root* - ім'я користувача бази даних; *DB_PASSWORD* - пароль користувача, що зберігається у файлі config.py; *127.0.0.1:3306* - адреса і порт бази даних: 127.0.0.1 — це локальний хост (localhost), а 3306 — стандартний порт для MySQL; *mydb* - назва бази даних, до якої відбувається підключення.

```python
engine = create_engine(SQLALCHEMY_DATABASE_URL)
```
**create_engine()** створює підключення до бази даних. Це об'єкт, через який відбувається взаємодія з базою даних.

```python
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
```
**sessionmaker** створює фабрику сесій, яка дозволяє створювати нові екземпляри сесій для взаємодії з базою даних. ```autocommit=False``` означає, що автоматичне збереження змін вимкнено. Відповідно всі зміни потрібно зберігати вручну за допомогою ```session.commit()```. ```autoflush=False``` означає, що автоматичне оновлення кешу вимкнено. Це допомагає уникнути потенційних проблем із несинхронізованими даними. ```bind=engine``` - прив'язка сесії до об'єкта engine, що забезпечує підключення до бази даних.

```python
Base = declarative_base()
```
**declarative_base()** створює базовий клас Base, від якого будуть успадковуватися всі моделі (таблиці). Це дозволяє визначати таблиці у вигляді Python-класів, де атрибути класу відповідають стовпцям таблиці.

### main.py
Із першим файлом ми закінчили, тепер переходимо до головного файла додатка FastAPI, який називається **main.py**. Він є точкою входу для запуску сервера FastAPI і включає базові налаштування, підключення до бази даних, а також маршрути (endpoints).

![](./images/software/2.png)

**Імпорти:**  *FastAPI* — це основний клас фреймворка FastAPI, який дозволяє створювати веб-додатки; *engine* і *Base* — імпортуються з модуля database.py, вони відповідають за підключення до бази даних та декларативну базу моделей; *router* — імпортується з модуля routes.py (цим ми займемося трохи пізніше) і містить всі маршрути (endpoints).

```python
Base.metadata.create_all(bind=engine)
```

**Base.metadata.create_all()** — це метод SQLAlchemy, який використовується для створення всіх таблиць у базі даних, визначених у моделях; ```bind=engine``` визначає, до якої бази даних підключатися для створення таблиць.

```python
app = FastAPI()
```

**FastAPI()** створює новий екземпляр додатка FastAPI, який є основою для всіх HTTP-запитів та відповідає за обробку маршрутів.

```python
app.include_router(router)
```

**include_router()** — метод FastAPI, який підключає маршрутизатор (router) до основного додатка; *router* — це об'єкт, що містить визначені маршрути (endpoints) для обробки HTTP-запитів.

На цьому налаштування доступу до бази даних закінчено. Тепер можемо переходити до створення Pydantic-схем та моделей SQLAlchemy.

## Створення Pydantic-схем та моделей SQLAlchemy
Зараз ми займемося описом схеми бази даних за допомогою **ORM (Object-Relational Mapping)**. Завдяки SQLAlchemy ми можемо працювати з базою даних як із Python-об'єктами, а не писати SQL-запити вручну.

[**ORM (об'єктно-реляційне відображення)**](https://uk.wikipedia.org/wiki/Об%27єктно-реляційне_відображення) - це технологія програмування, яка зв'язує бази даних з концепціями об'єктно-орієнтованих мов програмування, створюючи «віртуальну об'єктну базу даних».

### models.py
У файлі **models.py** визначимо дві моделі бази даних: *Product* та *Orders* - за допомогою SQLAlchemy, які відображають таблиці в базі даних MySQL.

![](./images/software/3.png)

**Імпорти**: *Column*, *Integer*, *String*, *DateTime*, *ForeignKey* імпортуються з SQLAlchemy і використовуються для визначення типів полів таблиці та зв'язків між таблицями; *relationship* — функція SQLAlchemy, яка використовується для встановлення зв'язків між таблицями; *Base* — імпортується з файлу database.py; *datetime*, *timezone*, *timedelta* — стандартні модулі Python для роботи з датами та часом.

![](./images/software/4.png)

Тут ми реалізували модель, що відображає табличку *Product* в нашій базі даних. Клас **Product** відповідає за збереження інформації про продукти в базі даних та містить методи для роботи з цією інформацією за допомогою ORM. ```primary_key=True``` є параметром, що вказує на поле, яке повинно бути основним ключем таблиці в базі даних. Параметр ```autoincrement=True``` означає, що значення цього поля буде автоматично збільшуватися при кожному новому записі в таблиці. Параметр ```index=True``` означає, що буде створено індекс для цього поля для швидшого пошуку. Параметр ```unique=True``` гарантує, що всі значення в цій колонці будуть унікальними (тобто не буде двох продуктів з однаковими назвами). Параметр ```nullable=True``` означає, що це поле може бути порожнім (необов'язковим).

```python
orders = relationship("Orders", back_populates="product")
```

Тут відображено зв'язок **"один-до-багатьох"** із таблицею Orders. Поле relationship створює зв'язок між моделями, що дозволяє отримувати всі замовлення, пов'язані з певним продуктом.

![](./images/software/5.png)

Клас **Orders** зберігає інформацію про замовлення, пов'язуючи їх із продуктами. Це дозволяє відстежувати, які продукти були замовлені, коли і в якій кількості.

```python
order_date = Column(DateTime, default=lambda: datetime.now(timezone.utc) + timedelta(hours=2))
```

Варто зауважити, що тут ми використали *default*, щоб за замовчуванням поточні дата і час встановлювалися, як дата і час замовлення.

```python
product = relationship("Product", back_populates="orders")
```

Тут відображено зв'язок **"багато-до-одного"** з таблицею Product. Це дозволяє отримати інформацію про продукт, пов'язаний із конкретним замовленням.

### schemas.py
Тут ми займемося визначенням схем Pydantic для моделей Product та Order у проєкті FastAPI. Його основна мета — описати структуру даних, що використовуються в запитах і відповідях API.

**Pydantic схема** — це клас, який описує модель даних у Python, використовуючи бібліотеку Pydantic. Pydantic дозволяє валідувати та перевіряти вхідні дані, автоматично конвертувати типи, а також створювати коректні дані на основі визначених типів. Pydantic значно спрощує роботу з валідацією даних, особливо в таких випадках, як робота з API, конфігураціями або будь-якими іншими структурами даних, що потребують перевірки на відповідність певним вимогам.

![](./images/software/6.png)

**Імпорти**: *BaseModel* — базовий клас Pydantic, від якого успадковуються всі схеми; *Optional* — використовується для полів, які можуть бути відсутніми або мати значення None; *datetime* — стандартний модуль Python для роботи з датами та часом.

![](./images/software/8.1.png)

Схема **OrderResponse** містить всі поля моделі Orders. Тут вказуємо типи полів (int, str, datatime). Загалом ця схема використовується для формування відповіді сервера при запиті даних про замовлення, а також забезпечує серіалізацію об'єктів у JSON.

![](./images/software/7.png)

Схема **OrderCreate** використовується для валідації даних при створенні нового замовлення або оновлення існуючих (HTTP-запит POST та HTTP-запит PUT). Тут для деяких полів встановлюємо *Optional*, що вказує на необов'язкове для заповнення поле. Справді, id можна не заповнювати, адже для нього встановлено autoincrement, а для order_date ми встановили значення за замовчуванням під час створення моделей.

![](./images/software/9.png)

У схемі **OrderPatch** усі поля є необов'язковими, що дозволяє оновлювати лише окремі поля замовлення. Вона використовується для часткового оновлення даних про замовлення (HTTP-запит PATCH).

Аналогічно створюємо схеми для **Product**.

## Реалізація основних маршрутів API
Тепер ми перейдемо до чи не найважливішої частини роботи. У файлі **routes.py** ми визначимо маршрути для створення, читання, оновлення, видалення та часткового оновлення записів у базі даних, використовуючи ORM SQLAlchemy.

![](./images/software/10.png)

**Імпорти**: *APIRouter* використовується для створення групи маршрутів; *Depends* дозволяє використовувати залежності (наприклад, сесію бази даних); *HTTPException* дозволяє піднімати HTTP-помилки; *Session* представляє сесію з базою даних; *List* використовується для типізації списків; *models* - модулі, що містять моделі таблиць (Product, Orders); *schemas* - модулі, що містять схеми запитів і відповідей (ProductCreate, OrderCreate тощо); *SessionLocal* - функція для створення сесії з базою даних.

```python
router = APIRouter()
```

Тут ми створюємо об'єкт маршрутизатора (APIRouter), який використовується для визначення та організації HTTP-роутів (endpoint'ів) API.

![](./images/software/11.png)

Ця функція використовується як залежність у FastAPI для забезпечення доступу до сесії бази даних (Session) в API-запитах. *SessionLocal* — це об'єкт, створений за допомогою sessionmaker у SQLAlchemy. Він використовується для створення нової сесії бази даних. Сесія потрібна для виконання операцій **CRUD** (Create, Read, Update, Delete). 

*yield* повертає об'єкт db як генератор, що дозволяє використовувати його у функціях-запитах (endpoints).

Після завершення виконання запиту (незалежно від того, чи був він успішним, чи сталася помилка) сесія закривається. Це допомагає уникнути витоку ресурсів.

Зараз ми опишемо реалізацію маршрутів для **Orders**, а для Product ви вже зможете це зробити самостійно.

### GET
Get-запит відповідає за отримання даних. У нашому випадку реалізуємо два варіанти: отримання даних всіх замовлень та отримання даних окремого замовлення за id.

![](./images/software/12.png)

Цей ендпоінт реалізує HTTP-запит GET для отримання списку замовлень. ```@router.get("/orders/")``` вказує, що цей ендпоінт буде доступний за URL-адресою /orders/; ```response_model=List[OrderResponse]``` вказує на схему відповіді, яку повинен повертати ендпоінт; ```List[OrderResponse]``` означає, що відповідь буде списком об'єктів, які відповідають схемі OrderResponse; ```db: Session = Depends(get_db)``` - це залежність FastAPI, що забезпечує доступ до сесії бази даних (```Depends(get_db)``` викликає функцію get_db(), яка створює сесію бази даних).

Ця функція виконує запит до таблиці Orders через метод ```.query()```  і повертає всі записи з таблиці у вигляді списку об'єктів.

![](./images/software/13.png)

Цей ендпоінт використовується для отримання конкретного замовлення за його id. ```response_model=OrderResponse``` вказує, що відповідь буде відповідати схемі OrderResponse. *order_id* - це параметр функції, який отримує значення id продукту з URL.

```python
db_order = db.query(Orders).filter(order_id == Orders.id).first()
```

```db.query(Orders)``` виконує запит до таблиці Orders; ```.filter(order_id == Orders.id)``` застосовує фільтр, де значення id продукту дорівнює переданому параметру order_id; ```.first()``` - повертає перший знайдений запис або None, якщо запис не знайдено. 

```python
if db_order is None:
    raise HTTPException(status_code=404, detail="The order with the specified ID was not found")
```

Якщо замовлення не знайдено, піднімається виключення HTTPException з кодом помилки 404 та повідомленням.

```python
return db_order
```

Повертаємо знайдене замовлення у форматі, що відповідає схемі.

### POST
Post-запит відповідає за додавання даних.

![](./images/software/14.png)

Ця функція реалізує POST-запит для створення нового замовлення в базі даних. ```order: OrderCreate``` - це параметр функції, що представляє тіло запиту. *OrderCreate* — це схема, яка визначає поля, що очікуються у тілі запиту (наприклад, id, product_id, quantity, тощо). FastAPI автоматично перетворює дані з JSON у відповідний Python-об'єкт (OrderCreate).

```python
id_order = db.query(Orders).filter(order.id == Orders.id).first()
if id_order:
    raise HTTPException(status_code=400, detail="The order with this ID already exists")

id_product = db.query(Product).filter(order.product_id == Product.id).first()
if not id_product:
    raise HTTPException(status_code=400, detail="The product with the specified ID was not found")
```

Тут ми перевіряємо, чи не існує в базі даних замовлення з таким id і чи існує продукт із замовлення в табличці Product. Якщо умови перевірки не виконуються, повертаються помилки з відповідним описом.

```python
db_order = Orders(**order.dict())
db.add(db_order)
db.commit()
db.refresh(db_order)

return db_order
```

```order.dict()``` - перетворює об'єкт OrderCreate на словник Python. ```Orders(**order.dict())``` виконує розпакування словника і передає значення як аргументи для створення об'єкта Orders. ```db.add(db_order)``` додає новий об'єкт Orders до сесії. ```db.commit()``` фіксує зміни в базі даних, тобто зберігає новий запис. ```db.refresh(db_order)``` оновлює об'єкт db_order з бази даних, щоб включити новостворене значення id.

### PUT
Put-запит відповідає за оновлення вже існуючих даних.

![](./images/software/15.png)

Ця функція реалізує PUT-запит для оновлення існуючого замовлення в базі даних.

```python
db_order = db.query(Orders).filter(order_id == Orders.id).first()
if db_order is None:
    raise HTTPException(status_code=404, detail="The order with the specified ID was not found")

id_order = db.query(Orders).filter(order.id == Orders.id, order_id != Orders.id).first()
if id_order:
    raise HTTPException(status_code=400, detail="The order with this ID already exists")

id_product = db.query(Product).filter(order.product_id == Product.id).first()
if not id_product:
    raise HTTPException(status_code=400, detail="The product with the specified ID was not found")
```

Тут реалізовано перевірку на існування замовлення з *order_id*; на існування замовлення з таким же id, як у нових даних; на існування продукту з таким *product_id*.


```python
for key, value in order.dict().items():
    setattr(db_order, key, value)
```

```order.dict()``` перетворює об'єкт OrderCreate на словник Python, де ключі — це імена атрибутів, а значення — їх нові значення. ```setattr(db_order, key, value)``` використовує функцію *setattr()* для оновлення атрибутів об'єкта db_order. Наприклад, якщо ключ — quantity, то виконується ```db_order.quantity = value```. Цей цикл оновлює всі поля замовлення новими значеннями з тіла запиту.

### DELETE
Delete-запит відповідає за видалення даних.

![](./images/software/16.png)

Ця функція реалізує DELETE-запит для видалення існуючого замовлення з бази даних за його order_id.

```python
db_order = db.query(Orders).filter(order_id == Orders.id).first()
if db_order is None:
    raise HTTPException(status_code=404, detail="The order with the specified ID was not found")
```

Перевірка на існування замовлення в Orders.

```python
db.delete(db_order)
```

Видаляє об'єкт замовлення з сесії бази даних; це означає, що замовлення буде видалене з бази даних під час наступного виклику ```commit()```.

### PATCH
Patch-запит відповідає за часткове оновлення вже існуючих даних.

![](./images/software/17.png)

Ця функція реалізує ендпоінт для часткового оновлення замовлення через HTTP-запит PATCH.

```python
db_order = db.query(Orders).filter(order_id == Orders.id).first()
if db_order is None:
    raise HTTPException(status_code=404, detail="The order with the specified ID was not found")

updated_fields = order.dict(exclude_unset=True)

if 'id' in updated_fields and updated_fields['id'] != order_id:
    id_order = db.query(Orders).filter(Orders.id == updated_fields['id']).first()
    if id_order:
        raise HTTPException(status_code=400, detail="The order with this ID already exists")

if 'product_id' in updated_fields:
    id_product = db.query(Product).filter(Orders.id == updated_fields['product_id']).first()
    if not id_product:
        raise HTTPException(status_code=400, detail="The product with the specified ID was not found")
```

Тут спочатку перевіряється, чи змінено значення id чи product_id, а вже потім перевіряється існування замовлення; перевіряється, чи не ввів користувач новий id, замовлення з яким уже існує в базі; і чи не ввів користувач новий product_id, якого не існує в Product. ```exclude_unset=True``` - це параметр, що повертає словник, який містить лише ті поля, які були передані в запиті. Це дозволяє оновлювати лише вказані користувачем поля, а не всі поля замовлення. 

```python
for key, value in updated_fields.items():
    setattr(db_order, key, value)
```

Цикл проходить по всіх змінених полях і встановлює нові значення для об'єкта замовлення.

Фактично на цьому ми закінчили реалізацію RESTful API для **Orders**. Нижче ви можете побачити, як можна перевірити працездатність сервісу за допомогою **Postman**.
## Запуск сервера FastAPI і тестування
### Запуск FastAPI сервера
Для початку нам треба активувати віртуальне середовище та запустити FastAPI сервер. Переходимо в термінал усередині PyCharm. Якщо ви ще не створили віртуальне середовище проєкту (воно допомагає ізолювати залежності проєкту), зробіть це за допомогою наступної команди:

```
python -m venv .venv
```

Тепер нам необхідно активувати віртуальне середовище за допомогою команди:

```
.venv\Scripts\activate   
```

І після цього запускаємо сервер FastAPI командою:
```
uvicorn main:app --reload  
```

Якщо ви все зробили правильно, то маєте отримати приблизно таку відповідь:

![](./images/test/1.png)
### Тестування основного сценарію
Тестування **GET-запиту** для отримання всіх замовлень:

![](./images/test/2.png)

Тестування **GET-запиту** для отримання замовлення за id:

![](./images/test/3.png)

Тестування **POST-запиту** для додавання замовлення:

![](./images/test/4.png)

*Тут ми не вводили id та дату, і, як бачимо, система самостійно згенерувала id та встановила поточний час у замовленні.*

Тестування **PUT-запиту** на оновлення замовлення:

![](./images/test/5.png)

Тестування **DELETE-запиту** на видалення замовлення:

![](./images/test/6.png)

Тестування **PATCH-запиту** на часткове оновлення замовлення:

![](./images/test/7.png)

### Тестування виключних ситуацій
Для різних запитів виключні ситуації повторюються, тому ми наведемо приклад лише для основних із них.

Тестування **GET-запиту** для отримання неіснуючого замовлення:

![](./images/test/8.png)

Тестування **POST-запиту** для додавання замовлення з неіснуючим товаром:

![](./images/test/9.png)

Тестування **DELETE-запиту** на видалення неіснуючого замовлення:

![](./images/test/10.png)

## Документація FastAPI
FastAPI надає вбудовану інтерактивну документацію для всіх створених вами RESTful API. Це одна з ключових особливостей фреймворка, що значно полегшує розробку, тестування та використання API. За замовчуванням FastAPI автоматично створює документацію в двох форматах:

**Swagger UI** — доступна за адресою ```/docs```.

**Redoc** — доступна за адресою ```/redoc```.

Зараз ми розглянемо обидва варіанти докладніше.

### Swagger UI
**Swagger UI** — це інтерактивна документація, яка надає зручний інтерфейс для перегляду та тестування API. Вона створюється автоматично на основі API-ендпоінтів, моделей даних та типів параметрів.

Основні можливості Swagger UI:
- *інтерактивність* (дозволяє тестувати ендпоінти безпосередньо в браузері);
- *опис параметрів запиту* (для кожного ендпоінту вказані всі параметри, їх типи та опис);
- *моделі даних* (на основі Pydantic-моделі автоматично створюються схеми даних (input/output));
- *статус-коди відповіді* (відображає можливі статус-коди відповіді та їх опис).

Щоб відкрити Swagger UI, запустіть сервер FastAPI та перейдіть в браузері за адресою ```http://127.0.0.1:8000/docs```.

![](./images/test/11.png)

Приклад тестування GET-запиту на отримання замовлення за id:

![](./images/test/12.png)

### Redoc
**Redoc** — це ще один формат документації, який має більш формальний вигляд і підходить для публікації документації API. Він надає більш структуровану інформацію з акцентом на опис моделей та типів даних.

Основні можливості Redoc:
- *зручна навігація* (ліворуч знаходиться панель навігації з усіма ендпоінтами);
- *детальна інформація про моделі* (Redoc показує всю інформацію про моделі Pydantic, включаючи описи полів та типи даних);
- *чітка структура* (більш формальний підхід до відображення документації, що підходить для зовнішнього використання).

Щоб відкрити Swagger UI, запустіть сервер FastAPI та перейдіть в браузері за адресою ```http://127.0.0.1:8000/redoc```.

![](./images/test/13.png)

## Висновки
Використання FastAPI та SQLAlchemy забезпечує високопродуктивне рішення для створення RESTful API, яке легко масштабувати, розширювати та підтримувати. Цей стек технологій є чудовим вибором як для невеликих проєктів, так і для великих систем завдяки його гнучкості, продуктивності та зручності розробки.

У цьому гайді ми намагалися максимально зрозуміло та детально пояснити, як створити RESTful API мовою Python. Сподіваємося, що цей матеріал став для вас справді корисним і допоміг розібратися в основних моментах розробки.

P.S. Ще раз нагадуємо, що всі коди та файл бази даних ви можете знайти в директорії ```/software``` цього репозиторію.
## Посилання

1. *[Вступ до REST API](https://robotdreams.cc/uk/blog/466-vstup-do-rest-api-restful-vebservisi)*
2. *[REST API як спосіб спілкування компонент веб-додатків](https://foxminded.ua/shcho-take-rest-api/)*
3. *[FastAPI](https://en.wikipedia.org/wiki/FastAPI)*
4. *[SQLAlchemy Documentation](https://docs.sqlalchemy.org/en/13/orm/extensions/declarative/basic_use.html)*
5. *[ORM (об'єктно-реляційне відображення)](https://uk.wikipedia.org/wiki/Об%27єктно-реляційне_відображення)*
